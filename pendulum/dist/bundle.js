var pendulum =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/odex/src/odex.js":
/*!***************************************!*\
  !*** ./node_modules/odex/src/odex.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * An implementation of ODEX, by E. Hairer and G. Wanner, ported from the Fortran ODEX.F.\n * The original work carries the BSD 2-clause license, and so does this.\n *\n * Copyright (c) 2016 Colin Smith.\n * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following\n * disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the\n * following disclaimer in the documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\n * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Outcome;\n(function (Outcome) {\n    Outcome[Outcome[\"Converged\"] = 0] = \"Converged\";\n    Outcome[Outcome[\"MaxStepsExceeded\"] = 1] = \"MaxStepsExceeded\";\n    Outcome[Outcome[\"EarlyReturn\"] = 2] = \"EarlyReturn\";\n})(Outcome = exports.Outcome || (exports.Outcome = {}));\nvar Solver = (function () {\n    function Solver(n) {\n        this.n = n;\n        this.uRound = 2.3e-16;\n        this.maxSteps = 10000;\n        this.initialStepSize = 1e-4;\n        this.maxStepSize = 0;\n        this.maxExtrapolationColumns = 9;\n        this.stepSizeSequence = 0;\n        this.stabilityCheckCount = 1;\n        this.stabilityCheckTableLines = 2;\n        this.denseOutput = false;\n        this.denseOutputErrorEstimator = true;\n        this.denseComponents = undefined;\n        this.interpolationFormulaDegree = 4;\n        this.stepSizeReductionFactor = 0.5;\n        this.stepSizeFac1 = 0.02;\n        this.stepSizeFac2 = 4.0;\n        this.stepSizeFac3 = 0.8;\n        this.stepSizeFac4 = 0.9;\n        this.stepSafetyFactor1 = 0.65;\n        this.stepSafetyFactor2 = 0.94;\n        this.relativeTolerance = 1e-5;\n        this.absoluteTolerance = 1e-5;\n        this.debug = false;\n    }\n    Solver.prototype.grid = function (dt, out) {\n        if (!this.denseOutput)\n            throw new Error('Must set .denseOutput to true when using grid');\n        var components = this.denseComponents;\n        if (!components) {\n            components = [];\n            for (var i = 0; i < this.n; ++i)\n                components.push(i);\n        }\n        var t;\n        return function (n, xOld, x, y, interpolate) {\n            if (n === 1) {\n                var v = out(x, y);\n                t = x + dt;\n                return v;\n            }\n            while (t <= x) {\n                var yf = [];\n                for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {\n                    var i = components_1[_i];\n                    yf.push(interpolate(i, t));\n                }\n                var v = out(t, yf);\n                if (v === false)\n                    return false;\n                t += dt;\n            }\n        };\n    };\n    // Make a 1-based 2D array, with r rows and c columns. The initial values are undefined.\n    Solver.dim2 = function (r, c) {\n        var a = new Array(r + 1);\n        for (var i = 1; i <= r; ++i)\n            a[i] = Solver.dim(c);\n        return a;\n    };\n    // Generate step size sequence and return as a 1-based array of length n.\n    Solver.stepSizeSequence = function (nSeq, n) {\n        var a = new Array(n + 1);\n        a[0] = 0;\n        switch (nSeq) {\n            case 1:\n                for (var i = 1; i <= n; ++i)\n                    a[i] = 2 * i;\n                break;\n            case 2:\n                a[1] = 2;\n                for (var i = 2; i <= n; ++i)\n                    a[i] = 4 * i - 4;\n                break;\n            case 3:\n                a[1] = 2;\n                a[2] = 4;\n                a[3] = 6;\n                for (var i = 4; i <= n; ++i)\n                    a[i] = 2 * a[i - 2];\n                break;\n            case 4:\n                for (var i = 1; i <= n; ++i)\n                    a[i] = 4 * i - 2;\n                break;\n            case 5:\n                for (var i = 1; i <= n; ++i)\n                    a[i] = 4 * i;\n                break;\n            default:\n                throw new Error('invalid stepSizeSequence selected');\n        }\n        return a;\n    };\n    // Integrate the differential system represented by f, from x to xEnd, with initial data y.\n    // solOut, if provided, is called at each integration step.\n    Solver.prototype.solve = function (f, x, y0, xEnd, solOut) {\n        var _this = this;\n        // Make a copy of y0, 1-based. We leave the user's parameters alone so that they may be reused if desired.\n        var y = [0].concat(y0);\n        var dz = Solver.dim(this.n);\n        var yh1 = Solver.dim(this.n);\n        var yh2 = Solver.dim(this.n);\n        if (this.maxSteps <= 0)\n            throw new Error('maxSteps must be positive');\n        var km = this.maxExtrapolationColumns;\n        if (km <= 2)\n            throw new Error('maxExtrapolationColumns must be > 2');\n        var nSeq = this.stepSizeSequence || (this.denseOutput ? 4 : 1);\n        if (nSeq <= 3 && this.denseOutput)\n            throw new Error('stepSizeSequence incompatible with denseOutput');\n        if (this.denseOutput && !solOut)\n            throw new Error('denseOutput requires a solution observer function');\n        if (this.interpolationFormulaDegree <= 0 || this.interpolationFormulaDegree >= 7)\n            throw new Error('bad interpolationFormulaDegree');\n        var icom = [0]; // icom will be 1-based, so start with a pad entry.\n        var nrdens = 0;\n        if (this.denseOutput) {\n            if (this.denseComponents) {\n                for (var _i = 0, _a = this.denseComponents; _i < _a.length; _i++) {\n                    var c = _a[_i];\n                    // convert dense components requested into one-based indexing.\n                    if (c < 0 || c > this.n)\n                        throw new Error('bad dense component: ' + c);\n                    icom.push(c + 1);\n                    ++nrdens;\n                }\n            }\n            else {\n                // if user asked for dense output but did not specify any denseComponents,\n                // request all of them.\n                for (var i = 1; i <= this.n; ++i) {\n                    icom.push(i);\n                }\n                nrdens = this.n;\n            }\n        }\n        if (this.uRound <= 1e-35 || this.uRound > 1)\n            throw new Error('suspicious value of uRound');\n        var hMax = Math.abs(this.maxStepSize || xEnd - x);\n        var lfSafe = 2 * km * km + km;\n        function expandToArray(x, n) {\n            // If x is an array, return a 1-based copy of it. If x is a number, return a new 1-based array\n            // consisting of n copies of the number.\n            var tolArray = [0];\n            if (Array.isArray(x)) {\n                return tolArray.concat(x);\n            }\n            else {\n                for (var i = 0; i < n; ++i)\n                    tolArray.push(x);\n                return tolArray;\n            }\n        }\n        var aTol = expandToArray(this.absoluteTolerance, this.n);\n        var rTol = expandToArray(this.relativeTolerance, this.n);\n        var _b = [0, 0, 0, 0], nEval = _b[0], nStep = _b[1], nAccept = _b[2], nReject = _b[3];\n        // call to core integrator\n        var nrd = Math.max(1, nrdens);\n        var ncom = Math.max(1, (2 * km + 5) * nrdens);\n        var dens = Solver.dim(ncom);\n        var fSafe = Solver.dim2(lfSafe, nrd);\n        // Wrap f in a function F which hides the one-based indexing from the customers.\n        var F = function (x, y, yp) {\n            var ret = f(x, y.slice(1));\n            for (var i = 0; i < ret.length; ++i)\n                yp[i + 1] = ret[i];\n        };\n        var odxcor = function () {\n            // The following three variables are COMMON/CONTEX/\n            var xOldd;\n            var hhh;\n            var kmit;\n            var acceptStep = function (n) {\n                // Returns true if we should continue the integration. The only time false\n                // is returned is when the user's solution observation function has returned false,\n                // indicating that she does not wish to continue the computation.\n                xOld = x;\n                x += h;\n                if (_this.denseOutput) {\n                    // kmit = mu of the paper\n                    kmit = 2 * kc - _this.interpolationFormulaDegree + 1;\n                    for (var i = 1; i <= nrd; ++i)\n                        dens[i] = y[icom[i]];\n                    xOldd = xOld;\n                    hhh = h; // note: xOldd and hhh are part of /CONODX/\n                    for (var i = 1; i <= nrd; ++i)\n                        dens[nrd + i] = h * dz[icom[i]];\n                    var kln = 2 * nrd;\n                    for (var i = 1; i <= nrd; ++i)\n                        dens[kln + i] = t[1][icom[i]];\n                    // compute solution at mid-point\n                    for (var j = 2; j <= kc; ++j) {\n                        var dblenj = nj[j];\n                        for (var l = j; l >= 2; --l) {\n                            var factor = Math.pow((dblenj / nj[l - 1]), 2) - 1;\n                            for (var i = 1; i <= nrd; ++i) {\n                                ySafe[l - 1][i] = ySafe[l][i] + (ySafe[l][i] - ySafe[l - 1][i]) / factor;\n                            }\n                        }\n                    }\n                    var krn = 4 * nrd;\n                    for (var i = 1; i <= nrd; ++i)\n                        dens[krn + i] = ySafe[1][i];\n                    // compute first derivative at right end\n                    for (var i = 1; i <= n; ++i)\n                        yh1[i] = t[1][i];\n                    F(x, yh1, yh2);\n                    krn = 3 * nrd;\n                    for (var i = 1; i <= nrd; ++i)\n                        dens[krn + i] = yh2[icom[i]] * h;\n                    // THE LOOP\n                    for (var kmi = 1; kmi <= kmit; ++kmi) {\n                        // compute kmi-th derivative at mid-point\n                        var kbeg = (kmi + 1) / 2 | 0;\n                        for (var kk = kbeg; kk <= kc; ++kk) {\n                            var facnj = Math.pow((nj[kk] / 2), (kmi - 1));\n                            iPt = iPoint[kk + 1] - 2 * kk + kmi;\n                            for (var i = 1; i <= nrd; ++i) {\n                                ySafe[kk][i] = fSafe[iPt][i] * facnj;\n                            }\n                        }\n                        for (var j = kbeg + 1; j <= kc; ++j) {\n                            var dblenj = nj[j];\n                            for (var l = j; l >= kbeg + 1; --l) {\n                                var factor = Math.pow((dblenj / nj[l - 1]), 2) - 1;\n                                for (var i = 1; i <= nrd; ++i) {\n                                    ySafe[l - 1][i] = ySafe[l][i] + (ySafe[l][i] - ySafe[l - 1][i]) / factor;\n                                }\n                            }\n                        }\n                        krn = (kmi + 4) * nrd;\n                        for (var i = 1; i <= nrd; ++i)\n                            dens[krn + i] = ySafe[kbeg][i] * h;\n                        if (kmi === kmit)\n                            continue;\n                        // compute differences\n                        for (var kk = (kmi + 2) / 2 | 0; kk <= kc; ++kk) {\n                            var lbeg = iPoint[kk + 1];\n                            var lend = iPoint[kk] + kmi + 1;\n                            if (kmi === 1 && nSeq === 4)\n                                lend += 2;\n                            var l = void 0;\n                            for (l = lbeg; l >= lend; l -= 2) {\n                                for (var i = 1; i <= nrd; ++i) {\n                                    fSafe[l][i] -= fSafe[l - 2][i];\n                                }\n                            }\n                            if (kmi === 1 && nSeq === 4) {\n                                l = lend - 2;\n                                for (var i = 1; i <= nrd; ++i)\n                                    fSafe[l][i] -= dz[icom[i]];\n                            }\n                        }\n                        // compute differences\n                        for (var kk = (kmi + 2) / 2 | 0; kk <= kc; ++kk) {\n                            var lbeg = iPoint[kk + 1] - 1;\n                            var lend = iPoint[kk] + kmi + 2;\n                            for (var l = lbeg; l >= lend; l -= 2) {\n                                for (var i = 1; i <= nrd; ++i) {\n                                    fSafe[l][i] -= fSafe[l - 2][i];\n                                }\n                            }\n                        }\n                    }\n                    interp(nrd, dens, kmit);\n                    // estimation of interpolation error\n                    if (_this.denseOutputErrorEstimator && kmit >= 1) {\n                        var errint = 0;\n                        for (var i = 1; i <= nrd; ++i)\n                            errint += Math.pow((dens[(kmit + 4) * nrd + i] / scal[icom[i]]), 2);\n                        errint = Math.sqrt(errint / nrd) * errfac[kmit];\n                        hoptde = h / Math.max(Math.pow(errint, (1 / (kmit + 4))), 0.01);\n                        if (errint > 10) {\n                            h = hoptde;\n                            x = xOld;\n                            ++nReject;\n                            reject = true;\n                            return true;\n                        }\n                    }\n                    for (var i = 1; i <= n; ++i)\n                        dz[i] = yh2[i];\n                }\n                for (var i = 1; i <= n; ++i)\n                    y[i] = t[1][i];\n                ++nAccept;\n                if (solOut) {\n                    // If denseOutput, we also want to supply the dense closure.\n                    if (solOut(nAccept + 1, xOld, x, y.slice(1), _this.denseOutput && contex(xOldd, hhh, kmit, dens, icom)) === false)\n                        return false;\n                }\n                // compute optimal order\n                var kopt;\n                if (kc === 2) {\n                    kopt = Math.min(3, km - 1);\n                    if (reject)\n                        kopt = 2;\n                }\n                else {\n                    if (kc <= k) {\n                        kopt = kc;\n                        if (w[kc - 1] < w[kc] * _this.stepSizeFac3)\n                            kopt = kc - 1;\n                        if (w[kc] < w[kc - 1] * _this.stepSizeFac4)\n                            kopt = Math.min(kc + 1, km - 1);\n                    }\n                    else {\n                        kopt = kc - 1;\n                        if (kc > 3 && w[kc - 2] < w[kc - 1] * _this.stepSizeFac3)\n                            kopt = kc - 2;\n                        if (w[kc] < w[kopt] * _this.stepSizeFac4)\n                            kopt = Math.min(kc, km - 1);\n                    }\n                }\n                // after a rejected step\n                if (reject) {\n                    k = Math.min(kopt, kc);\n                    h = posneg * Math.min(Math.abs(h), Math.abs(hh[k]));\n                    reject = false;\n                    return true; // goto 10\n                }\n                if (kopt <= kc) {\n                    h = hh[kopt];\n                }\n                else {\n                    if (kc < k && w[kc] < w[kc - 1] * _this.stepSizeFac4) {\n                        h = hh[kc] * a[kopt + 1] / a[kc];\n                    }\n                    else {\n                        h = hh[kc] * a[kopt] / a[kc];\n                    }\n                }\n                // compute stepsize for next step\n                k = kopt;\n                h = posneg * Math.abs(h);\n                return true;\n            };\n            var midex = function (j) {\n                var dy = Solver.dim(_this.n);\n                // Computes the jth line of the extrapolation table and\n                // provides an estimation of the optional stepsize\n                var hj = h / nj[j];\n                // Euler starting step\n                for (var i = 1; i <= _this.n; ++i) {\n                    yh1[i] = y[i];\n                    yh2[i] = y[i] + hj * dz[i];\n                }\n                // Explicit midpoint rule\n                var m = nj[j] - 1;\n                var njMid = (nj[j] / 2) | 0;\n                for (var mm = 1; mm <= m; ++mm) {\n                    if (_this.denseOutput && mm === njMid) {\n                        for (var i = 1; i <= nrd; ++i) {\n                            ySafe[j][i] = yh2[icom[i]];\n                        }\n                    }\n                    F(x + hj * mm, yh2, dy);\n                    if (_this.denseOutput && Math.abs(mm - njMid) <= 2 * j - 1) {\n                        ++iPt;\n                        for (var i = 1; i <= nrd; ++i) {\n                            fSafe[iPt][i] = dy[icom[i]];\n                        }\n                    }\n                    for (var i = 1; i <= _this.n; ++i) {\n                        var ys = yh1[i];\n                        yh1[i] = yh2[i];\n                        yh2[i] = ys + 2 * hj * dy[i];\n                    }\n                    if (mm <= _this.stabilityCheckCount && j <= _this.stabilityCheckTableLines) {\n                        // stability check\n                        var del1 = 0;\n                        for (var i = 1; i <= _this.n; ++i) {\n                            del1 += Math.pow((dz[i] / scal[i]), 2);\n                        }\n                        var del2 = 0;\n                        for (var i = 1; i <= _this.n; ++i) {\n                            del2 += Math.pow(((dy[i] - dz[i]) / scal[i]), 2);\n                        }\n                        var quot = del2 / Math.max(_this.uRound, del1);\n                        if (quot > 4) {\n                            ++nEval;\n                            atov = true;\n                            h *= _this.stepSizeReductionFactor;\n                            reject = true;\n                            return;\n                        }\n                    }\n                }\n                // final smoothing step\n                F(x + h, yh2, dy);\n                if (_this.denseOutput && njMid <= 2 * j - 1) {\n                    ++iPt;\n                    for (var i = 1; i <= nrd; ++i) {\n                        fSafe[iPt][i] = dy[icom[i]];\n                    }\n                }\n                for (var i = 1; i <= _this.n; ++i) {\n                    t[j][i] = (yh1[i] + yh2[i] + hj * dy[i]) / 2;\n                }\n                nEval += nj[j];\n                // polynomial extrapolation\n                if (j === 1)\n                    return; // was j.eq.1\n                var dblenj = nj[j];\n                var fac;\n                for (var l = j; l > 1; --l) {\n                    fac = Math.pow((dblenj / nj[l - 1]), 2) - 1;\n                    for (var i = 1; i <= _this.n; ++i) {\n                        t[l - 1][i] = t[l][i] + (t[l][i] - t[l - 1][i]) / fac;\n                    }\n                }\n                err = 0;\n                // scaling\n                for (var i = 1; i <= _this.n; ++i) {\n                    var t1i = Math.max(Math.abs(y[i]), Math.abs(t[1][i]));\n                    scal[i] = aTol[i] + rTol[i] * t1i;\n                    err += Math.pow(((t[1][i] - t[2][i]) / scal[i]), 2);\n                }\n                err = Math.sqrt(err / _this.n);\n                if (err * _this.uRound >= 1 || (j > 2 && err >= errOld)) {\n                    atov = true;\n                    h *= _this.stepSizeReductionFactor;\n                    reject = true;\n                    return;\n                }\n                errOld = Math.max(4 * err, 1);\n                // compute optimal stepsizes\n                var exp0 = 1 / (2 * j - 1);\n                var facMin = Math.pow(_this.stepSizeFac1, exp0);\n                fac = Math.min(_this.stepSizeFac2 / facMin, Math.max(facMin, Math.pow((err / _this.stepSafetyFactor1), exp0) / _this.stepSafetyFactor2));\n                fac = 1 / fac;\n                hh[j] = Math.min(Math.abs(h) * fac, hMax);\n                w[j] = a[j] / hh[j];\n            };\n            var interp = function (n, y, imit) {\n                // computes the coefficients of the interpolation formula\n                var a = new Array(31); // zero-based: 0:30\n                // begin with Hermite interpolation\n                for (var i = 1; i <= n; ++i) {\n                    var y0_1 = y[i];\n                    var y1 = y[2 * n + i];\n                    var yp0 = y[n + i];\n                    var yp1 = y[3 * n + i];\n                    var yDiff = y1 - y0_1;\n                    var aspl = -yp1 + yDiff;\n                    var bspl = yp0 - yDiff;\n                    y[n + i] = yDiff;\n                    y[2 * n + i] = aspl;\n                    y[3 * n + i] = bspl;\n                    if (imit < 0)\n                        continue;\n                    // compute the derivatives of Hermite at midpoint\n                    var ph0 = (y0_1 + y1) * 0.5 + 0.125 * (aspl + bspl);\n                    var ph1 = yDiff + (aspl - bspl) * 0.25;\n                    var ph2 = -(yp0 - yp1);\n                    var ph3 = 6 * (bspl - aspl);\n                    // compute the further coefficients\n                    if (imit >= 1) {\n                        a[1] = 16 * (y[5 * n + i] - ph1);\n                        if (imit >= 3) {\n                            a[3] = 16 * (y[7 * n + i] - ph3 + 3 * a[1]);\n                            if (imit >= 5) {\n                                for (var im = 5; im <= imit; im += 2) {\n                                    var fac1 = im * (im - 1) / 2;\n                                    var fac2 = fac1 * (im - 2) * (im - 3) * 2;\n                                    a[im] = 16 * (y[(im + 4) * n + i] + fac1 * a[im - 2] - fac2 * a[im - 4]);\n                                }\n                            }\n                        }\n                    }\n                    a[0] = (y[4 * n + i] - ph0) * 16;\n                    if (imit >= 2) {\n                        a[2] = (y[n * 6 + i] - ph2 + a[0]) * 16;\n                        if (imit >= 4) {\n                            for (var im = 4; im <= imit; im += 2) {\n                                var fac1 = im * (im - 1) / 2;\n                                var fac2 = im * (im - 1) * (im - 2) * (im - 3);\n                                a[im] = (y[n * (im + 4) + i] + a[im - 2] * fac1 - a[im - 4] * fac2) * 16;\n                            }\n                        }\n                    }\n                    for (var im = 0; im <= imit; ++im)\n                        y[n * (im + 4) + i] = a[im];\n                }\n            };\n            var contex = function (xOld, h, imit, y, icom) {\n                return function (c, x) {\n                    var i = 0;\n                    for (var j = 1; j <= nrd; ++j) {\n                        // careful: customers describe components 0-based. We record indices 1-based.\n                        if (icom[j] === c + 1)\n                            i = j;\n                    }\n                    if (i === 0)\n                        throw new Error('no dense output available for component ' + c);\n                    var theta = (x - xOld) / h;\n                    var theta1 = 1 - theta;\n                    var phthet = y[i] + theta * (y[nrd + i] + theta1 * (y[2 * nrd + i] * theta + y[3 * nrd + i] * theta1));\n                    if (imit < 0)\n                        return phthet;\n                    var thetah = theta - 0.5;\n                    var ret = y[nrd * (imit + 4) + i];\n                    for (var im = imit; im >= 1; --im) {\n                        ret = y[nrd * (im + 3) + i] + ret * thetah / im;\n                    }\n                    return phthet + Math.pow((theta * theta1), 2) * ret;\n                };\n            };\n            // preparation\n            var ySafe = Solver.dim2(km, nrd);\n            var hh = Solver.dim(km);\n            var t = Solver.dim2(km, _this.n);\n            // Define the step size sequence\n            var nj = Solver.stepSizeSequence(nSeq, km);\n            // Define the a[i] for order selection\n            var a = Solver.dim(km);\n            a[1] = 1 + nj[1];\n            for (var i = 2; i <= km; ++i) {\n                a[i] = a[i - 1] + nj[i];\n            }\n            // Initial Scaling\n            var scal = Solver.dim(_this.n);\n            for (var i = 1; i <= _this.n; ++i) {\n                scal[i] = aTol[i] + rTol[i] + Math.abs(y[i]);\n            }\n            // Initial preparations\n            var posneg = xEnd - x >= 0 ? 1 : -1;\n            var k = Math.max(2, Math.min(km - 1, Math.floor(-Solver.log10(rTol[1] + 1e-40) * 0.6 + 1.5)));\n            var h = Math.max(Math.abs(_this.initialStepSize), 1e-4);\n            h = posneg * Math.min(h, hMax, Math.abs(xEnd - x) / 2);\n            var iPoint = Solver.dim(km + 1);\n            var errfac = Solver.dim(2 * km);\n            var xOld = x;\n            var iPt = 0;\n            if (solOut) {\n                if (_this.denseOutput) {\n                    iPoint[1] = 0;\n                    for (var i = 1; i <= km; ++i) {\n                        var njAdd = 4 * i - 2;\n                        if (nj[i] > njAdd)\n                            ++njAdd;\n                        iPoint[i + 1] = iPoint[i] + njAdd;\n                    }\n                    for (var mu = 1; mu <= 2 * km; ++mu) {\n                        var errx = Math.sqrt(mu / (mu + 4)) * 0.5;\n                        var prod = Math.pow((1 / (mu + 4)), 2);\n                        for (var j = 1; j <= mu; ++j)\n                            prod *= errx / j;\n                        errfac[mu] = prod;\n                    }\n                    iPt = 0;\n                }\n                // check return value and abandon integration if called for\n                if (false === solOut(nAccept + 1, xOld, x, y.slice(1))) {\n                    return Outcome.EarlyReturn;\n                }\n            }\n            var err = 0;\n            var errOld = 1e10;\n            var hoptde = posneg * hMax;\n            var w = Solver.dim(km);\n            w[1] = 0;\n            var reject = false;\n            var last = false;\n            var atov;\n            var kc = 0;\n            var STATE;\n            (function (STATE) {\n                STATE[STATE[\"Start\"] = 0] = \"Start\";\n                STATE[STATE[\"BasicIntegrationStep\"] = 1] = \"BasicIntegrationStep\";\n                STATE[STATE[\"ConvergenceStep\"] = 2] = \"ConvergenceStep\";\n                STATE[STATE[\"HopeForConvergence\"] = 3] = \"HopeForConvergence\";\n                STATE[STATE[\"Accept\"] = 4] = \"Accept\";\n                STATE[STATE[\"Reject\"] = 5] = \"Reject\";\n            })(STATE || (STATE = {}));\n            var state = STATE.Start;\n            loop: while (true) {\n                _this.debug && console.log('STATE', STATE[state], nStep, xOld, x, h, k, kc, hoptde);\n                switch (state) {\n                    case STATE.Start:\n                        atov = false;\n                        // Is xEnd reached in the next step?\n                        if (0.1 * Math.abs(xEnd - x) <= Math.abs(x) * _this.uRound)\n                            break loop;\n                        h = posneg * Math.min(Math.abs(h), Math.abs(xEnd - x), hMax, Math.abs(hoptde));\n                        if ((x + 1.01 * h - xEnd) * posneg > 0) {\n                            h = xEnd - x;\n                            last = true;\n                        }\n                        if (nStep === 0 || !_this.denseOutput) {\n                            F(x, y, dz);\n                            ++nEval;\n                        }\n                        // The first and last step\n                        if (nStep === 0 || last) {\n                            iPt = 0;\n                            ++nStep;\n                            for (var j = 1; j <= k; ++j) {\n                                kc = j;\n                                midex(j);\n                                if (atov)\n                                    continue loop;\n                                if (j > 1 && err <= 1) {\n                                    state = STATE.Accept;\n                                    continue loop;\n                                }\n                            }\n                            state = STATE.HopeForConvergence;\n                            continue;\n                        }\n                        state = STATE.BasicIntegrationStep;\n                        continue;\n                    case STATE.BasicIntegrationStep:\n                        // basic integration step\n                        iPt = 0;\n                        ++nStep;\n                        if (nStep >= _this.maxSteps) {\n                            return Outcome.MaxStepsExceeded;\n                        }\n                        kc = k - 1;\n                        for (var j = 1; j <= kc; ++j) {\n                            midex(j);\n                            if (atov) {\n                                state = STATE.Start;\n                                continue loop;\n                            }\n                        }\n                        // convergence monitor\n                        if (k === 2 || reject) {\n                            state = STATE.ConvergenceStep;\n                        }\n                        else {\n                            if (err <= 1) {\n                                state = STATE.Accept;\n                            }\n                            else if (err > Math.pow(((nj[k + 1] * nj[k]) / 4), 2)) {\n                                state = STATE.Reject;\n                            }\n                            else\n                                state = STATE.ConvergenceStep;\n                        }\n                        continue;\n                    case STATE.ConvergenceStep:\n                        midex(k);\n                        if (atov) {\n                            state = STATE.Start;\n                            continue;\n                        }\n                        kc = k;\n                        if (err <= 1) {\n                            state = STATE.Accept;\n                            continue;\n                        }\n                        state = STATE.HopeForConvergence;\n                        continue;\n                    case STATE.HopeForConvergence:\n                        // hope for convergence in line k + 1\n                        if (err > Math.pow((nj[k + 1] / 2), 2)) {\n                            state = STATE.Reject;\n                            continue;\n                        }\n                        kc = k + 1;\n                        midex(kc);\n                        if (atov)\n                            state = STATE.Start;\n                        else if (err > 1)\n                            state = STATE.Reject;\n                        else\n                            state = STATE.Accept;\n                        continue;\n                    case STATE.Accept:\n                        if (!acceptStep(_this.n))\n                            return Outcome.EarlyReturn;\n                        state = STATE.Start;\n                        continue;\n                    case STATE.Reject:\n                        k = Math.min(k, kc, km - 1);\n                        if (k > 2 && w[k - 1] < w[k] * _this.stepSizeFac3)\n                            k -= 1;\n                        ++nReject;\n                        h = posneg * hh[k];\n                        reject = true;\n                        state = STATE.BasicIntegrationStep;\n                }\n            }\n            return Outcome.Converged;\n        };\n        var outcome = odxcor();\n        return {\n            y: y.slice(1),\n            outcome: outcome,\n            nStep: nStep,\n            xEnd: xEnd,\n            nAccept: nAccept,\n            nReject: nReject,\n            nEval: nEval\n        };\n    };\n    return Solver;\n}());\n// return a 1-based array of length n. Initial values undefined.\nSolver.dim = function (n) { return Array(n + 1); };\nSolver.log10 = function (x) { return Math.log(x) / Math.LN10; };\nexports.Solver = Solver;\n//# sourceMappingURL=odex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb2RleC9zcmMvb2RleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovL3BlbmR1bHVtLy4vbm9kZV9tb2R1bGVzL29kZXgvc3JjL29kZXguanM/MmQ5OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgT0RFWCwgYnkgRS4gSGFpcmVyIGFuZCBHLiBXYW5uZXIsIHBvcnRlZCBmcm9tIHRoZSBGb3J0cmFuIE9ERVguRi5cbiAqIFRoZSBvcmlnaW5hbCB3b3JrIGNhcnJpZXMgdGhlIEJTRCAyLWNsYXVzZSBsaWNlbnNlLCBhbmQgc28gZG9lcyB0aGlzLlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNiBDb2xpbiBTbWl0aC5cbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqIGRpc2NsYWltZXIuXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGVcbiAqIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsXG4gKiBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsXG4gKiBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEVcbiAqIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWVxuICogT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE91dGNvbWU7XG4oZnVuY3Rpb24gKE91dGNvbWUpIHtcbiAgICBPdXRjb21lW091dGNvbWVbXCJDb252ZXJnZWRcIl0gPSAwXSA9IFwiQ29udmVyZ2VkXCI7XG4gICAgT3V0Y29tZVtPdXRjb21lW1wiTWF4U3RlcHNFeGNlZWRlZFwiXSA9IDFdID0gXCJNYXhTdGVwc0V4Y2VlZGVkXCI7XG4gICAgT3V0Y29tZVtPdXRjb21lW1wiRWFybHlSZXR1cm5cIl0gPSAyXSA9IFwiRWFybHlSZXR1cm5cIjtcbn0pKE91dGNvbWUgPSBleHBvcnRzLk91dGNvbWUgfHwgKGV4cG9ydHMuT3V0Y29tZSA9IHt9KSk7XG52YXIgU29sdmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTb2x2ZXIobikge1xuICAgICAgICB0aGlzLm4gPSBuO1xuICAgICAgICB0aGlzLnVSb3VuZCA9IDIuM2UtMTY7XG4gICAgICAgIHRoaXMubWF4U3RlcHMgPSAxMDAwMDtcbiAgICAgICAgdGhpcy5pbml0aWFsU3RlcFNpemUgPSAxZS00O1xuICAgICAgICB0aGlzLm1heFN0ZXBTaXplID0gMDtcbiAgICAgICAgdGhpcy5tYXhFeHRyYXBvbGF0aW9uQ29sdW1ucyA9IDk7XG4gICAgICAgIHRoaXMuc3RlcFNpemVTZXF1ZW5jZSA9IDA7XG4gICAgICAgIHRoaXMuc3RhYmlsaXR5Q2hlY2tDb3VudCA9IDE7XG4gICAgICAgIHRoaXMuc3RhYmlsaXR5Q2hlY2tUYWJsZUxpbmVzID0gMjtcbiAgICAgICAgdGhpcy5kZW5zZU91dHB1dCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlbnNlT3V0cHV0RXJyb3JFc3RpbWF0b3IgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlbnNlQ29tcG9uZW50cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0aW9uRm9ybXVsYURlZ3JlZSA9IDQ7XG4gICAgICAgIHRoaXMuc3RlcFNpemVSZWR1Y3Rpb25GYWN0b3IgPSAwLjU7XG4gICAgICAgIHRoaXMuc3RlcFNpemVGYWMxID0gMC4wMjtcbiAgICAgICAgdGhpcy5zdGVwU2l6ZUZhYzIgPSA0LjA7XG4gICAgICAgIHRoaXMuc3RlcFNpemVGYWMzID0gMC44O1xuICAgICAgICB0aGlzLnN0ZXBTaXplRmFjNCA9IDAuOTtcbiAgICAgICAgdGhpcy5zdGVwU2FmZXR5RmFjdG9yMSA9IDAuNjU7XG4gICAgICAgIHRoaXMuc3RlcFNhZmV0eUZhY3RvcjIgPSAwLjk0O1xuICAgICAgICB0aGlzLnJlbGF0aXZlVG9sZXJhbmNlID0gMWUtNTtcbiAgICAgICAgdGhpcy5hYnNvbHV0ZVRvbGVyYW5jZSA9IDFlLTU7XG4gICAgICAgIHRoaXMuZGVidWcgPSBmYWxzZTtcbiAgICB9XG4gICAgU29sdmVyLnByb3RvdHlwZS5ncmlkID0gZnVuY3Rpb24gKGR0LCBvdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlbnNlT3V0cHV0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNldCAuZGVuc2VPdXRwdXQgdG8gdHJ1ZSB3aGVuIHVzaW5nIGdyaWQnKTtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSB0aGlzLmRlbnNlQ29tcG9uZW50cztcbiAgICAgICAgaWYgKCFjb21wb25lbnRzKSB7XG4gICAgICAgICAgICBjb21wb25lbnRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubjsgKytpKVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuLCB4T2xkLCB4LCB5LCBpbnRlcnBvbGF0ZSkge1xuICAgICAgICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IG91dCh4LCB5KTtcbiAgICAgICAgICAgICAgICB0ID0geCArIGR0O1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHQgPD0geCkge1xuICAgICAgICAgICAgICAgIHZhciB5ZiA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgY29tcG9uZW50c18xID0gY29tcG9uZW50czsgX2kgPCBjb21wb25lbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gY29tcG9uZW50c18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgeWYucHVzaChpbnRlcnBvbGF0ZShpLCB0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB2ID0gb3V0KHQsIHlmKTtcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB0ICs9IGR0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8gTWFrZSBhIDEtYmFzZWQgMkQgYXJyYXksIHdpdGggciByb3dzIGFuZCBjIGNvbHVtbnMuIFRoZSBpbml0aWFsIHZhbHVlcyBhcmUgdW5kZWZpbmVkLlxuICAgIFNvbHZlci5kaW0yID0gZnVuY3Rpb24gKHIsIGMpIHtcbiAgICAgICAgdmFyIGEgPSBuZXcgQXJyYXkociArIDEpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSByOyArK2kpXG4gICAgICAgICAgICBhW2ldID0gU29sdmVyLmRpbShjKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbiAgICAvLyBHZW5lcmF0ZSBzdGVwIHNpemUgc2VxdWVuY2UgYW5kIHJldHVybiBhcyBhIDEtYmFzZWQgYXJyYXkgb2YgbGVuZ3RoIG4uXG4gICAgU29sdmVyLnN0ZXBTaXplU2VxdWVuY2UgPSBmdW5jdGlvbiAoblNlcSwgbikge1xuICAgICAgICB2YXIgYSA9IG5ldyBBcnJheShuICsgMSk7XG4gICAgICAgIGFbMF0gPSAwO1xuICAgICAgICBzd2l0Y2ggKG5TZXEpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBuOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGFbaV0gPSAyICogaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBhWzFdID0gMjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMjsgaSA8PSBuOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGFbaV0gPSA0ICogaSAtIDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgYVsxXSA9IDI7XG4gICAgICAgICAgICAgICAgYVsyXSA9IDQ7XG4gICAgICAgICAgICAgICAgYVszXSA9IDY7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDQ7IGkgPD0gbjsgKytpKVxuICAgICAgICAgICAgICAgICAgICBhW2ldID0gMiAqIGFbaSAtIDJdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG47ICsraSlcbiAgICAgICAgICAgICAgICAgICAgYVtpXSA9IDQgKiBpIC0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBuOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGFbaV0gPSA0ICogaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0ZXBTaXplU2VxdWVuY2Ugc2VsZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYTtcbiAgICB9O1xuICAgIC8vIEludGVncmF0ZSB0aGUgZGlmZmVyZW50aWFsIHN5c3RlbSByZXByZXNlbnRlZCBieSBmLCBmcm9tIHggdG8geEVuZCwgd2l0aCBpbml0aWFsIGRhdGEgeS5cbiAgICAvLyBzb2xPdXQsIGlmIHByb3ZpZGVkLCBpcyBjYWxsZWQgYXQgZWFjaCBpbnRlZ3JhdGlvbiBzdGVwLlxuICAgIFNvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbiAoZiwgeCwgeTAsIHhFbmQsIHNvbE91dCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBNYWtlIGEgY29weSBvZiB5MCwgMS1iYXNlZC4gV2UgbGVhdmUgdGhlIHVzZXIncyBwYXJhbWV0ZXJzIGFsb25lIHNvIHRoYXQgdGhleSBtYXkgYmUgcmV1c2VkIGlmIGRlc2lyZWQuXG4gICAgICAgIHZhciB5ID0gWzBdLmNvbmNhdCh5MCk7XG4gICAgICAgIHZhciBkeiA9IFNvbHZlci5kaW0odGhpcy5uKTtcbiAgICAgICAgdmFyIHloMSA9IFNvbHZlci5kaW0odGhpcy5uKTtcbiAgICAgICAgdmFyIHloMiA9IFNvbHZlci5kaW0odGhpcy5uKTtcbiAgICAgICAgaWYgKHRoaXMubWF4U3RlcHMgPD0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWF4U3RlcHMgbXVzdCBiZSBwb3NpdGl2ZScpO1xuICAgICAgICB2YXIga20gPSB0aGlzLm1heEV4dHJhcG9sYXRpb25Db2x1bW5zO1xuICAgICAgICBpZiAoa20gPD0gMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWF4RXh0cmFwb2xhdGlvbkNvbHVtbnMgbXVzdCBiZSA+IDInKTtcbiAgICAgICAgdmFyIG5TZXEgPSB0aGlzLnN0ZXBTaXplU2VxdWVuY2UgfHwgKHRoaXMuZGVuc2VPdXRwdXQgPyA0IDogMSk7XG4gICAgICAgIGlmIChuU2VxIDw9IDMgJiYgdGhpcy5kZW5zZU91dHB1dClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3RlcFNpemVTZXF1ZW5jZSBpbmNvbXBhdGlibGUgd2l0aCBkZW5zZU91dHB1dCcpO1xuICAgICAgICBpZiAodGhpcy5kZW5zZU91dHB1dCAmJiAhc29sT3V0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZW5zZU91dHB1dCByZXF1aXJlcyBhIHNvbHV0aW9uIG9ic2VydmVyIGZ1bmN0aW9uJyk7XG4gICAgICAgIGlmICh0aGlzLmludGVycG9sYXRpb25Gb3JtdWxhRGVncmVlIDw9IDAgfHwgdGhpcy5pbnRlcnBvbGF0aW9uRm9ybXVsYURlZ3JlZSA+PSA3KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgaW50ZXJwb2xhdGlvbkZvcm11bGFEZWdyZWUnKTtcbiAgICAgICAgdmFyIGljb20gPSBbMF07IC8vIGljb20gd2lsbCBiZSAxLWJhc2VkLCBzbyBzdGFydCB3aXRoIGEgcGFkIGVudHJ5LlxuICAgICAgICB2YXIgbnJkZW5zID0gMDtcbiAgICAgICAgaWYgKHRoaXMuZGVuc2VPdXRwdXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbnNlQ29tcG9uZW50cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmRlbnNlQ29tcG9uZW50czsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgZGVuc2UgY29tcG9uZW50cyByZXF1ZXN0ZWQgaW50byBvbmUtYmFzZWQgaW5kZXhpbmcuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBjID4gdGhpcy5uKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgZGVuc2UgY29tcG9uZW50OiAnICsgYyk7XG4gICAgICAgICAgICAgICAgICAgIGljb20ucHVzaChjICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICsrbnJkZW5zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIHVzZXIgYXNrZWQgZm9yIGRlbnNlIG91dHB1dCBidXQgZGlkIG5vdCBzcGVjaWZ5IGFueSBkZW5zZUNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdCBhbGwgb2YgdGhlbS5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSB0aGlzLm47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICBpY29tLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5yZGVucyA9IHRoaXMubjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51Um91bmQgPD0gMWUtMzUgfHwgdGhpcy51Um91bmQgPiAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdXNwaWNpb3VzIHZhbHVlIG9mIHVSb3VuZCcpO1xuICAgICAgICB2YXIgaE1heCA9IE1hdGguYWJzKHRoaXMubWF4U3RlcFNpemUgfHwgeEVuZCAtIHgpO1xuICAgICAgICB2YXIgbGZTYWZlID0gMiAqIGttICoga20gKyBrbTtcbiAgICAgICAgZnVuY3Rpb24gZXhwYW5kVG9BcnJheSh4LCBuKSB7XG4gICAgICAgICAgICAvLyBJZiB4IGlzIGFuIGFycmF5LCByZXR1cm4gYSAxLWJhc2VkIGNvcHkgb2YgaXQuIElmIHggaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyAxLWJhc2VkIGFycmF5XG4gICAgICAgICAgICAvLyBjb25zaXN0aW5nIG9mIG4gY29waWVzIG9mIHRoZSBudW1iZXIuXG4gICAgICAgICAgICB2YXIgdG9sQXJyYXkgPSBbMF07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2xBcnJheS5jb25jYXQoeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICAgICAgICAgICAgICAgICAgdG9sQXJyYXkucHVzaCh4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9sQXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFUb2wgPSBleHBhbmRUb0FycmF5KHRoaXMuYWJzb2x1dGVUb2xlcmFuY2UsIHRoaXMubik7XG4gICAgICAgIHZhciByVG9sID0gZXhwYW5kVG9BcnJheSh0aGlzLnJlbGF0aXZlVG9sZXJhbmNlLCB0aGlzLm4pO1xuICAgICAgICB2YXIgX2IgPSBbMCwgMCwgMCwgMF0sIG5FdmFsID0gX2JbMF0sIG5TdGVwID0gX2JbMV0sIG5BY2NlcHQgPSBfYlsyXSwgblJlamVjdCA9IF9iWzNdO1xuICAgICAgICAvLyBjYWxsIHRvIGNvcmUgaW50ZWdyYXRvclxuICAgICAgICB2YXIgbnJkID0gTWF0aC5tYXgoMSwgbnJkZW5zKTtcbiAgICAgICAgdmFyIG5jb20gPSBNYXRoLm1heCgxLCAoMiAqIGttICsgNSkgKiBucmRlbnMpO1xuICAgICAgICB2YXIgZGVucyA9IFNvbHZlci5kaW0obmNvbSk7XG4gICAgICAgIHZhciBmU2FmZSA9IFNvbHZlci5kaW0yKGxmU2FmZSwgbnJkKTtcbiAgICAgICAgLy8gV3JhcCBmIGluIGEgZnVuY3Rpb24gRiB3aGljaCBoaWRlcyB0aGUgb25lLWJhc2VkIGluZGV4aW5nIGZyb20gdGhlIGN1c3RvbWVycy5cbiAgICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoeCwgeSwgeXApIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBmKHgsIHkuc2xpY2UoMSkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgeXBbaSArIDFdID0gcmV0W2ldO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb2R4Y29yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyB0aHJlZSB2YXJpYWJsZXMgYXJlIENPTU1PTi9DT05URVgvXG4gICAgICAgICAgICB2YXIgeE9sZGQ7XG4gICAgICAgICAgICB2YXIgaGhoO1xuICAgICAgICAgICAgdmFyIGttaXQ7XG4gICAgICAgICAgICB2YXIgYWNjZXB0U3RlcCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIHdlIHNob3VsZCBjb250aW51ZSB0aGUgaW50ZWdyYXRpb24uIFRoZSBvbmx5IHRpbWUgZmFsc2VcbiAgICAgICAgICAgICAgICAvLyBpcyByZXR1cm5lZCBpcyB3aGVuIHRoZSB1c2VyJ3Mgc29sdXRpb24gb2JzZXJ2YXRpb24gZnVuY3Rpb24gaGFzIHJldHVybmVkIGZhbHNlLFxuICAgICAgICAgICAgICAgIC8vIGluZGljYXRpbmcgdGhhdCBzaGUgZG9lcyBub3Qgd2lzaCB0byBjb250aW51ZSB0aGUgY29tcHV0YXRpb24uXG4gICAgICAgICAgICAgICAgeE9sZCA9IHg7XG4gICAgICAgICAgICAgICAgeCArPSBoO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5kZW5zZU91dHB1dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBrbWl0ID0gbXUgb2YgdGhlIHBhcGVyXG4gICAgICAgICAgICAgICAgICAgIGttaXQgPSAyICoga2MgLSBfdGhpcy5pbnRlcnBvbGF0aW9uRm9ybXVsYURlZ3JlZSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG5yZDsgKytpKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVuc1tpXSA9IHlbaWNvbVtpXV07XG4gICAgICAgICAgICAgICAgICAgIHhPbGRkID0geE9sZDtcbiAgICAgICAgICAgICAgICAgICAgaGhoID0gaDsgLy8gbm90ZTogeE9sZGQgYW5kIGhoaCBhcmUgcGFydCBvZiAvQ09OT0RYL1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBucmQ7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbnNbbnJkICsgaV0gPSBoICogZHpbaWNvbVtpXV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBrbG4gPSAyICogbnJkO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBucmQ7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbnNba2xuICsgaV0gPSB0WzFdW2ljb21baV1dO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb21wdXRlIHNvbHV0aW9uIGF0IG1pZC1wb2ludFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMjsgaiA8PSBrYzsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGJsZW5qID0gbmpbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gajsgbCA+PSAyOyAtLWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gTWF0aC5wb3coKGRibGVuaiAvIG5qW2wgLSAxXSksIDIpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBucmQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5U2FmZVtsIC0gMV1baV0gPSB5U2FmZVtsXVtpXSArICh5U2FmZVtsXVtpXSAtIHlTYWZlW2wgLSAxXVtpXSkgLyBmYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBrcm4gPSA0ICogbnJkO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBucmQ7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbnNba3JuICsgaV0gPSB5U2FmZVsxXVtpXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcHV0ZSBmaXJzdCBkZXJpdmF0aXZlIGF0IHJpZ2h0IGVuZFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBuOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICB5aDFbaV0gPSB0WzFdW2ldO1xuICAgICAgICAgICAgICAgICAgICBGKHgsIHloMSwgeWgyKTtcbiAgICAgICAgICAgICAgICAgICAga3JuID0gMyAqIG5yZDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbnJkOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZW5zW2tybiArIGldID0geWgyW2ljb21baV1dICogaDtcbiAgICAgICAgICAgICAgICAgICAgLy8gVEhFIExPT1BcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga21pID0gMTsga21pIDw9IGttaXQ7ICsra21pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wdXRlIGttaS10aCBkZXJpdmF0aXZlIGF0IG1pZC1wb2ludFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtiZWcgPSAoa21pICsgMSkgLyAyIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtrID0ga2JlZzsga2sgPD0ga2M7ICsra2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjbmogPSBNYXRoLnBvdygobmpba2tdIC8gMiksIChrbWkgLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaVB0ID0gaVBvaW50W2trICsgMV0gLSAyICoga2sgKyBrbWk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbnJkOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeVNhZmVba2tdW2ldID0gZlNhZmVbaVB0XVtpXSAqIGZhY25qO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBrYmVnICsgMTsgaiA8PSBrYzsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRibGVuaiA9IG5qW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSBqOyBsID49IGtiZWcgKyAxOyAtLWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IE1hdGgucG93KChkYmxlbmogLyBualtsIC0gMV0pLCAyKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG5yZDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5U2FmZVtsIC0gMV1baV0gPSB5U2FmZVtsXVtpXSArICh5U2FmZVtsXVtpXSAtIHlTYWZlW2wgLSAxXVtpXSkgLyBmYWN0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBrcm4gPSAoa21pICsgNCkgKiBucmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBucmQ7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZW5zW2tybiArIGldID0geVNhZmVba2JlZ11baV0gKiBoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGttaSA9PT0ga21pdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgZGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtrID0gKGttaSArIDIpIC8gMiB8IDA7IGtrIDw9IGtjOyArK2trKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxiZWcgPSBpUG9pbnRba2sgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZCA9IGlQb2ludFtra10gKyBrbWkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrbWkgPT09IDEgJiYgblNlcSA9PT0gNClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZCArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobCA9IGxiZWc7IGwgPj0gbGVuZDsgbCAtPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG5yZDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmU2FmZVtsXVtpXSAtPSBmU2FmZVtsIC0gMl1baV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGttaSA9PT0gMSAmJiBuU2VxID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwgPSBsZW5kIC0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbnJkOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmU2FmZVtsXVtpXSAtPSBkeltpY29tW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wdXRlIGRpZmZlcmVuY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrayA9IChrbWkgKyAyKSAvIDIgfCAwOyBrayA8PSBrYzsgKytraykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYmVnID0gaVBvaW50W2trICsgMV0gLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5kID0gaVBvaW50W2trXSArIGttaSArIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IGxiZWc7IGwgPj0gbGVuZDsgbCAtPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG5yZDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmU2FmZVtsXVtpXSAtPSBmU2FmZVtsIC0gMl1baV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJwKG5yZCwgZGVucywga21pdCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzdGltYXRpb24gb2YgaW50ZXJwb2xhdGlvbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZGVuc2VPdXRwdXRFcnJvckVzdGltYXRvciAmJiBrbWl0ID49IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJpbnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbnJkOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyaW50ICs9IE1hdGgucG93KChkZW5zWyhrbWl0ICsgNCkgKiBucmQgKyBpXSAvIHNjYWxbaWNvbVtpXV0pLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycmludCA9IE1hdGguc3FydChlcnJpbnQgLyBucmQpICogZXJyZmFjW2ttaXRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9wdGRlID0gaCAvIE1hdGgubWF4KE1hdGgucG93KGVycmludCwgKDEgLyAoa21pdCArIDQpKSksIDAuMDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycmludCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaCA9IGhvcHRkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0geE9sZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK25SZWplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBuOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBkeltpXSA9IHloMltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbjsgKytpKVxuICAgICAgICAgICAgICAgICAgICB5W2ldID0gdFsxXVtpXTtcbiAgICAgICAgICAgICAgICArK25BY2NlcHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNvbE91dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBkZW5zZU91dHB1dCwgd2UgYWxzbyB3YW50IHRvIHN1cHBseSB0aGUgZGVuc2UgY2xvc3VyZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvbE91dChuQWNjZXB0ICsgMSwgeE9sZCwgeCwgeS5zbGljZSgxKSwgX3RoaXMuZGVuc2VPdXRwdXQgJiYgY29udGV4KHhPbGRkLCBoaGgsIGttaXQsIGRlbnMsIGljb20pKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgb3B0aW1hbCBvcmRlclxuICAgICAgICAgICAgICAgIHZhciBrb3B0O1xuICAgICAgICAgICAgICAgIGlmIChrYyA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBrb3B0ID0gTWF0aC5taW4oMywga20gLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlamVjdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGtvcHQgPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtjIDw9IGspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtvcHQgPSBrYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3W2tjIC0gMV0gPCB3W2tjXSAqIF90aGlzLnN0ZXBTaXplRmFjMylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrb3B0ID0ga2MgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdba2NdIDwgd1trYyAtIDFdICogX3RoaXMuc3RlcFNpemVGYWM0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtvcHQgPSBNYXRoLm1pbihrYyArIDEsIGttIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrb3B0ID0ga2MgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtjID4gMyAmJiB3W2tjIC0gMl0gPCB3W2tjIC0gMV0gKiBfdGhpcy5zdGVwU2l6ZUZhYzMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga29wdCA9IGtjIC0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3W2tjXSA8IHdba29wdF0gKiBfdGhpcy5zdGVwU2l6ZUZhYzQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga29wdCA9IE1hdGgubWluKGtjLCBrbSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFmdGVyIGEgcmVqZWN0ZWQgc3RlcFxuICAgICAgICAgICAgICAgIGlmIChyZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IE1hdGgubWluKGtvcHQsIGtjKTtcbiAgICAgICAgICAgICAgICAgICAgaCA9IHBvc25lZyAqIE1hdGgubWluKE1hdGguYWJzKGgpLCBNYXRoLmFicyhoaFtrXSkpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIGdvdG8gMTBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtvcHQgPD0ga2MpIHtcbiAgICAgICAgICAgICAgICAgICAgaCA9IGhoW2tvcHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtjIDwgayAmJiB3W2tjXSA8IHdba2MgLSAxXSAqIF90aGlzLnN0ZXBTaXplRmFjNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IGhoW2tjXSAqIGFba29wdCArIDFdIC8gYVtrY107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gaGhba2NdICogYVtrb3B0XSAvIGFba2NdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgc3RlcHNpemUgZm9yIG5leHQgc3RlcFxuICAgICAgICAgICAgICAgIGsgPSBrb3B0O1xuICAgICAgICAgICAgICAgIGggPSBwb3NuZWcgKiBNYXRoLmFicyhoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgbWlkZXggPSBmdW5jdGlvbiAoaikge1xuICAgICAgICAgICAgICAgIHZhciBkeSA9IFNvbHZlci5kaW0oX3RoaXMubik7XG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZXMgdGhlIGp0aCBsaW5lIG9mIHRoZSBleHRyYXBvbGF0aW9uIHRhYmxlIGFuZFxuICAgICAgICAgICAgICAgIC8vIHByb3ZpZGVzIGFuIGVzdGltYXRpb24gb2YgdGhlIG9wdGlvbmFsIHN0ZXBzaXplXG4gICAgICAgICAgICAgICAgdmFyIGhqID0gaCAvIG5qW2pdO1xuICAgICAgICAgICAgICAgIC8vIEV1bGVyIHN0YXJ0aW5nIHN0ZXBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBfdGhpcy5uOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgeWgxW2ldID0geVtpXTtcbiAgICAgICAgICAgICAgICAgICAgeWgyW2ldID0geVtpXSArIGhqICogZHpbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IG1pZHBvaW50IHJ1bGVcbiAgICAgICAgICAgICAgICB2YXIgbSA9IG5qW2pdIC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgbmpNaWQgPSAobmpbal0gLyAyKSB8IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbW0gPSAxOyBtbSA8PSBtOyArK21tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5kZW5zZU91dHB1dCAmJiBtbSA9PT0gbmpNaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG5yZDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeVNhZmVbal1baV0gPSB5aDJbaWNvbVtpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgRih4ICsgaGogKiBtbSwgeWgyLCBkeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5kZW5zZU91dHB1dCAmJiBNYXRoLmFicyhtbSAtIG5qTWlkKSA8PSAyICogaiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsraVB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbnJkOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmU2FmZVtpUHRdW2ldID0gZHlbaWNvbVtpXV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gX3RoaXMubjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeXMgPSB5aDFbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB5aDFbaV0gPSB5aDJbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB5aDJbaV0gPSB5cyArIDIgKiBoaiAqIGR5W2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtbSA8PSBfdGhpcy5zdGFiaWxpdHlDaGVja0NvdW50ICYmIGogPD0gX3RoaXMuc3RhYmlsaXR5Q2hlY2tUYWJsZUxpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFiaWxpdHkgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWwxID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IF90aGlzLm47ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbDEgKz0gTWF0aC5wb3coKGR6W2ldIC8gc2NhbFtpXSksIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbDIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gX3RoaXMubjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsMiArPSBNYXRoLnBvdygoKGR5W2ldIC0gZHpbaV0pIC8gc2NhbFtpXSksIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHF1b3QgPSBkZWwyIC8gTWF0aC5tYXgoX3RoaXMudVJvdW5kLCBkZWwxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdW90ID4gNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrbkV2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRvdiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaCAqPSBfdGhpcy5zdGVwU2l6ZVJlZHVjdGlvbkZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmaW5hbCBzbW9vdGhpbmcgc3RlcFxuICAgICAgICAgICAgICAgIEYoeCArIGgsIHloMiwgZHkpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5kZW5zZU91dHB1dCAmJiBuak1pZCA8PSAyICogaiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgKytpUHQ7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG5yZDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmU2FmZVtpUHRdW2ldID0gZHlbaWNvbVtpXV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gX3RoaXMubjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRbal1baV0gPSAoeWgxW2ldICsgeWgyW2ldICsgaGogKiBkeVtpXSkgLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuRXZhbCArPSBualtqXTtcbiAgICAgICAgICAgICAgICAvLyBwb2x5bm9taWFsIGV4dHJhcG9sYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyB3YXMgai5lcS4xXG4gICAgICAgICAgICAgICAgdmFyIGRibGVuaiA9IG5qW2pdO1xuICAgICAgICAgICAgICAgIHZhciBmYWM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IGo7IGwgPiAxOyAtLWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFjID0gTWF0aC5wb3coKGRibGVuaiAvIG5qW2wgLSAxXSksIDIpIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gX3RoaXMubjsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0W2wgLSAxXVtpXSA9IHRbbF1baV0gKyAodFtsXVtpXSAtIHRbbCAtIDFdW2ldKSAvIGZhYztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcnIgPSAwO1xuICAgICAgICAgICAgICAgIC8vIHNjYWxpbmdcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBfdGhpcy5uOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQxaSA9IE1hdGgubWF4KE1hdGguYWJzKHlbaV0pLCBNYXRoLmFicyh0WzFdW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxbaV0gPSBhVG9sW2ldICsgclRvbFtpXSAqIHQxaTtcbiAgICAgICAgICAgICAgICAgICAgZXJyICs9IE1hdGgucG93KCgodFsxXVtpXSAtIHRbMl1baV0pIC8gc2NhbFtpXSksIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcnIgPSBNYXRoLnNxcnQoZXJyIC8gX3RoaXMubik7XG4gICAgICAgICAgICAgICAgaWYgKGVyciAqIF90aGlzLnVSb3VuZCA+PSAxIHx8IChqID4gMiAmJiBlcnIgPj0gZXJyT2xkKSkge1xuICAgICAgICAgICAgICAgICAgICBhdG92ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaCAqPSBfdGhpcy5zdGVwU2l6ZVJlZHVjdGlvbkZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcnJPbGQgPSBNYXRoLm1heCg0ICogZXJyLCAxKTtcbiAgICAgICAgICAgICAgICAvLyBjb21wdXRlIG9wdGltYWwgc3RlcHNpemVzXG4gICAgICAgICAgICAgICAgdmFyIGV4cDAgPSAxIC8gKDIgKiBqIC0gMSk7XG4gICAgICAgICAgICAgICAgdmFyIGZhY01pbiA9IE1hdGgucG93KF90aGlzLnN0ZXBTaXplRmFjMSwgZXhwMCk7XG4gICAgICAgICAgICAgICAgZmFjID0gTWF0aC5taW4oX3RoaXMuc3RlcFNpemVGYWMyIC8gZmFjTWluLCBNYXRoLm1heChmYWNNaW4sIE1hdGgucG93KChlcnIgLyBfdGhpcy5zdGVwU2FmZXR5RmFjdG9yMSksIGV4cDApIC8gX3RoaXMuc3RlcFNhZmV0eUZhY3RvcjIpKTtcbiAgICAgICAgICAgICAgICBmYWMgPSAxIC8gZmFjO1xuICAgICAgICAgICAgICAgIGhoW2pdID0gTWF0aC5taW4oTWF0aC5hYnMoaCkgKiBmYWMsIGhNYXgpO1xuICAgICAgICAgICAgICAgIHdbal0gPSBhW2pdIC8gaGhbal07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGludGVycCA9IGZ1bmN0aW9uIChuLCB5LCBpbWl0KSB7XG4gICAgICAgICAgICAgICAgLy8gY29tcHV0ZXMgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgaW50ZXJwb2xhdGlvbiBmb3JtdWxhXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBuZXcgQXJyYXkoMzEpOyAvLyB6ZXJvLWJhc2VkOiAwOjMwXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gd2l0aCBIZXJtaXRlIGludGVycG9sYXRpb25cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkwXzEgPSB5W2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTEgPSB5WzIgKiBuICsgaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB5cDAgPSB5W24gKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHlwMSA9IHlbMyAqIG4gKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHlEaWZmID0geTEgLSB5MF8xO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXNwbCA9IC15cDEgKyB5RGlmZjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJzcGwgPSB5cDAgLSB5RGlmZjtcbiAgICAgICAgICAgICAgICAgICAgeVtuICsgaV0gPSB5RGlmZjtcbiAgICAgICAgICAgICAgICAgICAgeVsyICogbiArIGldID0gYXNwbDtcbiAgICAgICAgICAgICAgICAgICAgeVszICogbiArIGldID0gYnNwbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltaXQgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXB1dGUgdGhlIGRlcml2YXRpdmVzIG9mIEhlcm1pdGUgYXQgbWlkcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBoMCA9ICh5MF8xICsgeTEpICogMC41ICsgMC4xMjUgKiAoYXNwbCArIGJzcGwpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGgxID0geURpZmYgKyAoYXNwbCAtIGJzcGwpICogMC4yNTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBoMiA9IC0oeXAwIC0geXAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBoMyA9IDYgKiAoYnNwbCAtIGFzcGwpO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb21wdXRlIHRoZSBmdXJ0aGVyIGNvZWZmaWNpZW50c1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1pdCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhWzFdID0gMTYgKiAoeVs1ICogbiArIGldIC0gcGgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWl0ID49IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhWzNdID0gMTYgKiAoeVs3ICogbiArIGldIC0gcGgzICsgMyAqIGFbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWl0ID49IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaW0gPSA1OyBpbSA8PSBpbWl0OyBpbSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjMSA9IGltICogKGltIC0gMSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhYzIgPSBmYWMxICogKGltIC0gMikgKiAoaW0gLSAzKSAqIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW2ltXSA9IDE2ICogKHlbKGltICsgNCkgKiBuICsgaV0gKyBmYWMxICogYVtpbSAtIDJdIC0gZmFjMiAqIGFbaW0gLSA0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYVswXSA9ICh5WzQgKiBuICsgaV0gLSBwaDApICogMTY7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbWl0ID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFbMl0gPSAoeVtuICogNiArIGldIC0gcGgyICsgYVswXSkgKiAxNjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWl0ID49IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpbSA9IDQ7IGltIDw9IGltaXQ7IGltICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhYzEgPSBpbSAqIChpbSAtIDEpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZhYzIgPSBpbSAqIChpbSAtIDEpICogKGltIC0gMikgKiAoaW0gLSAzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtpbV0gPSAoeVtuICogKGltICsgNCkgKyBpXSArIGFbaW0gLSAyXSAqIGZhYzEgLSBhW2ltIC0gNF0gKiBmYWMyKSAqIDE2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpbSA9IDA7IGltIDw9IGltaXQ7ICsraW0pXG4gICAgICAgICAgICAgICAgICAgICAgICB5W24gKiAoaW0gKyA0KSArIGldID0gYVtpbV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBjb250ZXggPSBmdW5jdGlvbiAoeE9sZCwgaCwgaW1pdCwgeSwgaWNvbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYywgeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDw9IG5yZDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYXJlZnVsOiBjdXN0b21lcnMgZGVzY3JpYmUgY29tcG9uZW50cyAwLWJhc2VkLiBXZSByZWNvcmQgaW5kaWNlcyAxLWJhc2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGljb21bal0gPT09IGMgKyAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBqO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBkZW5zZSBvdXRwdXQgYXZhaWxhYmxlIGZvciBjb21wb25lbnQgJyArIGMpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGhldGEgPSAoeCAtIHhPbGQpIC8gaDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZXRhMSA9IDEgLSB0aGV0YTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBodGhldCA9IHlbaV0gKyB0aGV0YSAqICh5W25yZCArIGldICsgdGhldGExICogKHlbMiAqIG5yZCArIGldICogdGhldGEgKyB5WzMgKiBucmQgKyBpXSAqIHRoZXRhMSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW1pdCA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGh0aGV0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGhldGFoID0gdGhldGEgLSAwLjU7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSB5W25yZCAqIChpbWl0ICsgNCkgKyBpXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaW0gPSBpbWl0OyBpbSA+PSAxOyAtLWltKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSB5W25yZCAqIChpbSArIDMpICsgaV0gKyByZXQgKiB0aGV0YWggLyBpbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGh0aGV0ICsgTWF0aC5wb3coKHRoZXRhICogdGhldGExKSwgMikgKiByZXQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBwcmVwYXJhdGlvblxuICAgICAgICAgICAgdmFyIHlTYWZlID0gU29sdmVyLmRpbTIoa20sIG5yZCk7XG4gICAgICAgICAgICB2YXIgaGggPSBTb2x2ZXIuZGltKGttKTtcbiAgICAgICAgICAgIHZhciB0ID0gU29sdmVyLmRpbTIoa20sIF90aGlzLm4pO1xuICAgICAgICAgICAgLy8gRGVmaW5lIHRoZSBzdGVwIHNpemUgc2VxdWVuY2VcbiAgICAgICAgICAgIHZhciBuaiA9IFNvbHZlci5zdGVwU2l6ZVNlcXVlbmNlKG5TZXEsIGttKTtcbiAgICAgICAgICAgIC8vIERlZmluZSB0aGUgYVtpXSBmb3Igb3JkZXIgc2VsZWN0aW9uXG4gICAgICAgICAgICB2YXIgYSA9IFNvbHZlci5kaW0oa20pO1xuICAgICAgICAgICAgYVsxXSA9IDEgKyBualsxXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAyOyBpIDw9IGttOyArK2kpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYVtpIC0gMV0gKyBualtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluaXRpYWwgU2NhbGluZ1xuICAgICAgICAgICAgdmFyIHNjYWwgPSBTb2x2ZXIuZGltKF90aGlzLm4pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gX3RoaXMubjsgKytpKSB7XG4gICAgICAgICAgICAgICAgc2NhbFtpXSA9IGFUb2xbaV0gKyByVG9sW2ldICsgTWF0aC5hYnMoeVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbml0aWFsIHByZXBhcmF0aW9uc1xuICAgICAgICAgICAgdmFyIHBvc25lZyA9IHhFbmQgLSB4ID49IDAgPyAxIDogLTE7XG4gICAgICAgICAgICB2YXIgayA9IE1hdGgubWF4KDIsIE1hdGgubWluKGttIC0gMSwgTWF0aC5mbG9vcigtU29sdmVyLmxvZzEwKHJUb2xbMV0gKyAxZS00MCkgKiAwLjYgKyAxLjUpKSk7XG4gICAgICAgICAgICB2YXIgaCA9IE1hdGgubWF4KE1hdGguYWJzKF90aGlzLmluaXRpYWxTdGVwU2l6ZSksIDFlLTQpO1xuICAgICAgICAgICAgaCA9IHBvc25lZyAqIE1hdGgubWluKGgsIGhNYXgsIE1hdGguYWJzKHhFbmQgLSB4KSAvIDIpO1xuICAgICAgICAgICAgdmFyIGlQb2ludCA9IFNvbHZlci5kaW0oa20gKyAxKTtcbiAgICAgICAgICAgIHZhciBlcnJmYWMgPSBTb2x2ZXIuZGltKDIgKiBrbSk7XG4gICAgICAgICAgICB2YXIgeE9sZCA9IHg7XG4gICAgICAgICAgICB2YXIgaVB0ID0gMDtcbiAgICAgICAgICAgIGlmIChzb2xPdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuZGVuc2VPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaVBvaW50WzFdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0ga207ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5qQWRkID0gNCAqIGkgLSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5qW2ldID4gbmpBZGQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytuakFkZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlQb2ludFtpICsgMV0gPSBpUG9pbnRbaV0gKyBuakFkZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBtdSA9IDE7IG11IDw9IDIgKiBrbTsgKyttdSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycnggPSBNYXRoLnNxcnQobXUgLyAobXUgKyA0KSkgKiAwLjU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvZCA9IE1hdGgucG93KCgxIC8gKG11ICsgNCkpLCAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDw9IG11OyArK2opXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZCAqPSBlcnJ4IC8gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycmZhY1ttdV0gPSBwcm9kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlQdCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHJldHVybiB2YWx1ZSBhbmQgYWJhbmRvbiBpbnRlZ3JhdGlvbiBpZiBjYWxsZWQgZm9yXG4gICAgICAgICAgICAgICAgaWYgKGZhbHNlID09PSBzb2xPdXQobkFjY2VwdCArIDEsIHhPbGQsIHgsIHkuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPdXRjb21lLkVhcmx5UmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlcnIgPSAwO1xuICAgICAgICAgICAgdmFyIGVyck9sZCA9IDFlMTA7XG4gICAgICAgICAgICB2YXIgaG9wdGRlID0gcG9zbmVnICogaE1heDtcbiAgICAgICAgICAgIHZhciB3ID0gU29sdmVyLmRpbShrbSk7XG4gICAgICAgICAgICB3WzFdID0gMDtcbiAgICAgICAgICAgIHZhciByZWplY3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBsYXN0ID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgYXRvdjtcbiAgICAgICAgICAgIHZhciBrYyA9IDA7XG4gICAgICAgICAgICB2YXIgU1RBVEU7XG4gICAgICAgICAgICAoZnVuY3Rpb24gKFNUQVRFKSB7XG4gICAgICAgICAgICAgICAgU1RBVEVbU1RBVEVbXCJTdGFydFwiXSA9IDBdID0gXCJTdGFydFwiO1xuICAgICAgICAgICAgICAgIFNUQVRFW1NUQVRFW1wiQmFzaWNJbnRlZ3JhdGlvblN0ZXBcIl0gPSAxXSA9IFwiQmFzaWNJbnRlZ3JhdGlvblN0ZXBcIjtcbiAgICAgICAgICAgICAgICBTVEFURVtTVEFURVtcIkNvbnZlcmdlbmNlU3RlcFwiXSA9IDJdID0gXCJDb252ZXJnZW5jZVN0ZXBcIjtcbiAgICAgICAgICAgICAgICBTVEFURVtTVEFURVtcIkhvcGVGb3JDb252ZXJnZW5jZVwiXSA9IDNdID0gXCJIb3BlRm9yQ29udmVyZ2VuY2VcIjtcbiAgICAgICAgICAgICAgICBTVEFURVtTVEFURVtcIkFjY2VwdFwiXSA9IDRdID0gXCJBY2NlcHRcIjtcbiAgICAgICAgICAgICAgICBTVEFURVtTVEFURVtcIlJlamVjdFwiXSA9IDVdID0gXCJSZWplY3RcIjtcbiAgICAgICAgICAgIH0pKFNUQVRFIHx8IChTVEFURSA9IHt9KSk7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBTVEFURS5TdGFydDtcbiAgICAgICAgICAgIGxvb3A6IHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGVidWcgJiYgY29uc29sZS5sb2coJ1NUQVRFJywgU1RBVEVbc3RhdGVdLCBuU3RlcCwgeE9sZCwgeCwgaCwgaywga2MsIGhvcHRkZSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFNUQVRFLlN0YXJ0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYXRvdiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXMgeEVuZCByZWFjaGVkIGluIHRoZSBuZXh0IHN0ZXA/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoMC4xICogTWF0aC5hYnMoeEVuZCAtIHgpIDw9IE1hdGguYWJzKHgpICogX3RoaXMudVJvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcG9zbmVnICogTWF0aC5taW4oTWF0aC5hYnMoaCksIE1hdGguYWJzKHhFbmQgLSB4KSwgaE1heCwgTWF0aC5hYnMoaG9wdGRlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHggKyAxLjAxICogaCAtIHhFbmQpICogcG9zbmVnID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGggPSB4RW5kIC0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuU3RlcCA9PT0gMCB8fCAhX3RoaXMuZGVuc2VPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBGKHgsIHksIGR6KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK25FdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZpcnN0IGFuZCBsYXN0IHN0ZXBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuU3RlcCA9PT0gMCB8fCBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaVB0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArK25TdGVwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDw9IGs7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrYyA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pZGV4KGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXRvdilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqID4gMSAmJiBlcnIgPD0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5BY2NlcHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuSG9wZUZvckNvbnZlcmdlbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5CYXNpY0ludGVncmF0aW9uU3RlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFNUQVRFLkJhc2ljSW50ZWdyYXRpb25TdGVwOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFzaWMgaW50ZWdyYXRpb24gc3RlcFxuICAgICAgICAgICAgICAgICAgICAgICAgaVB0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrblN0ZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoblN0ZXAgPj0gX3RoaXMubWF4U3RlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT3V0Y29tZS5NYXhTdGVwc0V4Y2VlZGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAga2MgPSBrIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDw9IGtjOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaWRleChqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXRvdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcmdlbmNlIG1vbml0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrID09PSAyIHx8IHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuQ29udmVyZ2VuY2VTdGVwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyciA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuQWNjZXB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnIgPiBNYXRoLnBvdygoKG5qW2sgKyAxXSAqIG5qW2tdKSAvIDQpLCAyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlJlamVjdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLkNvbnZlcmdlbmNlU3RlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFNUQVRFLkNvbnZlcmdlbmNlU3RlcDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pZGV4KGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0b3YpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAga2MgPSBrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyciA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5BY2NlcHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLkhvcGVGb3JDb252ZXJnZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFNUQVRFLkhvcGVGb3JDb252ZXJnZW5jZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhvcGUgZm9yIGNvbnZlcmdlbmNlIGluIGxpbmUgayArIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIgPiBNYXRoLnBvdygobmpbayArIDFdIC8gMiksIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5SZWplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBrYyA9IGsgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlkZXgoa2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0b3YpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5TdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVyciA+IDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5SZWplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5BY2NlcHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTVEFURS5BY2NlcHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFjY2VwdFN0ZXAoX3RoaXMubikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE91dGNvbWUuRWFybHlSZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU1RBVEUuUmVqZWN0OlxuICAgICAgICAgICAgICAgICAgICAgICAgayA9IE1hdGgubWluKGssIGtjLCBrbSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGsgPiAyICYmIHdbayAtIDFdIDwgd1trXSAqIF90aGlzLnN0ZXBTaXplRmFjMylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICArK25SZWplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcG9zbmVnICogaGhba107XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5CYXNpY0ludGVncmF0aW9uU3RlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT3V0Y29tZS5Db252ZXJnZWQ7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvdXRjb21lID0gb2R4Y29yKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5OiB5LnNsaWNlKDEpLFxuICAgICAgICAgICAgb3V0Y29tZTogb3V0Y29tZSxcbiAgICAgICAgICAgIG5TdGVwOiBuU3RlcCxcbiAgICAgICAgICAgIHhFbmQ6IHhFbmQsXG4gICAgICAgICAgICBuQWNjZXB0OiBuQWNjZXB0LFxuICAgICAgICAgICAgblJlamVjdDogblJlamVjdCxcbiAgICAgICAgICAgIG5FdmFsOiBuRXZhbFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFNvbHZlcjtcbn0oKSk7XG4vLyByZXR1cm4gYSAxLWJhc2VkIGFycmF5IG9mIGxlbmd0aCBuLiBJbml0aWFsIHZhbHVlcyB1bmRlZmluZWQuXG5Tb2x2ZXIuZGltID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIEFycmF5KG4gKyAxKTsgfTtcblNvbHZlci5sb2cxMCA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4xMDsgfTtcbmV4cG9ydHMuU29sdmVyID0gU29sdmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2RleC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/odex/src/odex.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: solve */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"solve\", function() { return solve; });\n/* harmony import */ var odex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! odex */ \"./node_modules/odex/src/odex.js\");\n/* harmony import */ var odex__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(odex__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst g = 9.81\n\n// arithmetic-geometric mean\nconst agm = (a, b) => {\n    let x = a, y = b\n    while (Math.abs(x - y) < 1e-5) {\n        const x1 = (x + y) / 2\n        const y1 = Math.sqrt(x * y)\n        x = x1\n        y = y1\n    }\n    return (x + y) / 2\n}\n// formula from https://en.wikipedia.org/wiki/Pendulum_(mathematics)\nconst getPertiod = (l, theta) => {\n    return 2.0 * Math.PI * Math.sqrt(l / g) / agm(1.0, Math.cos(theta / 2))\n}\n\nconst observer = (storage) => {\n    return (x, y) => {\n        storage.push([x].concat(y))\n    }\n}\n\nconst solve = (l, theta, dt) => {\n    const s = new odex__WEBPACK_IMPORTED_MODULE_0__[\"Solver\"](2)\n    s.denseOutput = true\n    const initialConditions = [\n        theta,\t// y[0] - Theta\n        .0\t\t// y[1] - Theta'\n    ]\n\n    const derivatives = (t, y) => {\n        return [y[1], - g / l * Math.sin(y[0])]\n    }\n\n    const results = []    \n    s.solve(derivatives, 0, initialConditions, getPertiod(l, theta), s.grid(dt, observer(results)))\n    return results\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wZW5kdWx1bS8uL3NyYy9pbmRleC5qcz9iNjM1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIG9kZXggZnJvbSAnb2RleCdcblxuY29uc3QgZyA9IDkuODFcblxuLy8gYXJpdGhtZXRpYy1nZW9tZXRyaWMgbWVhblxuY29uc3QgYWdtID0gKGEsIGIpID0+IHtcbiAgICBsZXQgeCA9IGEsIHkgPSBiXG4gICAgd2hpbGUgKE1hdGguYWJzKHggLSB5KSA8IDFlLTUpIHtcbiAgICAgICAgY29uc3QgeDEgPSAoeCArIHkpIC8gMlxuICAgICAgICBjb25zdCB5MSA9IE1hdGguc3FydCh4ICogeSlcbiAgICAgICAgeCA9IHgxXG4gICAgICAgIHkgPSB5MVxuICAgIH1cbiAgICByZXR1cm4gKHggKyB5KSAvIDJcbn1cbi8vIGZvcm11bGEgZnJvbSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QZW5kdWx1bV8obWF0aGVtYXRpY3MpXG5jb25zdCBnZXRQZXJ0aW9kID0gKGwsIHRoZXRhKSA9PiB7XG4gICAgcmV0dXJuIDIuMCAqIE1hdGguUEkgKiBNYXRoLnNxcnQobCAvIGcpIC8gYWdtKDEuMCwgTWF0aC5jb3ModGhldGEgLyAyKSlcbn1cblxuY29uc3Qgb2JzZXJ2ZXIgPSAoc3RvcmFnZSkgPT4ge1xuICAgIHJldHVybiAoeCwgeSkgPT4ge1xuICAgICAgICBzdG9yYWdlLnB1c2goW3hdLmNvbmNhdCh5KSlcbiAgICB9XG59XG5cbmNvbnN0IHNvbHZlID0gKGwsIHRoZXRhLCBkdCkgPT4ge1xuICAgIGNvbnN0IHMgPSBuZXcgb2RleC5Tb2x2ZXIoMilcbiAgICBzLmRlbnNlT3V0cHV0ID0gdHJ1ZVxuICAgIGNvbnN0IGluaXRpYWxDb25kaXRpb25zID0gW1xuICAgICAgICB0aGV0YSxcdC8vIHlbMF0gLSBUaGV0YVxuICAgICAgICAuMFx0XHQvLyB5WzFdIC0gVGhldGEnXG4gICAgXVxuXG4gICAgY29uc3QgZGVyaXZhdGl2ZXMgPSAodCwgeSkgPT4ge1xuICAgICAgICByZXR1cm4gW3lbMV0sIC0gZyAvIGwgKiBNYXRoLnNpbih5WzBdKV1cbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHRzID0gW10gICAgXG4gICAgcy5zb2x2ZShkZXJpdmF0aXZlcywgMCwgaW5pdGlhbENvbmRpdGlvbnMsIGdldFBlcnRpb2QobCwgdGhldGEpLCBzLmdyaWQoZHQsIG9ic2VydmVyKHJlc3VsdHMpKSlcbiAgICByZXR1cm4gcmVzdWx0c1xufVxuXG5cbmV4cG9ydCB7IHNvbHZlIH0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ })

/******/ });